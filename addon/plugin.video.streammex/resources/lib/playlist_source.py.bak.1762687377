import ast
import base64
import json
import os
import re
import zlib
from datetime import datetime

from . import epg
from . import m3u
from . import util

# --- Konstansok / minták ---
PLAYLIST_SUFFIX = ''.join(chr(x) for x in (98, 101, 101))  # "bee"
PLAYLIST_ADDON_ID = 'plugin.video.playlist' + PLAYLIST_SUFFIX

CACHE_FILENAME = 'playlist_cache.json'
STATE_FILENAME = 'playlist_state.json'

# exec(_(b'...')) szerű kód felismerése
EXEC_PATTERN = re.compile(r"exec\(\s*[A-Za-z_]\w*\(\s*(b[\"'](?:\\.|[^\"'])*[\"'])\s*\)\s*\)", re.DOTALL)
# HTTPS URL-ek
HTTPS_PATTERN = re.compile(r"https://[^\s'\"\\)]+")
# Fallback default payload (base64+zlib) kinyerése
FALLBACK_PATTERN = re.compile(r'FALLBACK_PAYLOAD\s*=\s*"""(.*?)"""', re.DOTALL)


class PlaylistCoordinator:
    def __init__(self, addon):
        self.addon = addon
        self.debug_logging = util.get_bool_setting(addon, 'debug_logging', False)

        profile_path = util.translate_path(addon.getAddonInfo('profile')) if addon else ''
        if profile_path:
            util.ensure_directory(profile_path)
        self.profile_path = profile_path

        self.cache_path = os.path.join(self.profile_path, CACHE_FILENAME)
        self.state_path = os.path.join(self.profile_path, STATE_FILENAME)

        self.playlist_path = self._resolve_output('output_m3u_path', 'Hungary.m3u')
        self.epg_path = self._resolve_output('output_epg_path', 'Hungary.xml')

        self._channel_cache = None

    # --- Kimeneti útvonalak feloldása ---
    def _resolve_output(self, setting_key, default_name):
        base_path = util.get_setting(self.addon, setting_key, None)
        if not base_path:
            base_path = util.translate_path(os.path.join(self.profile_path, default_name))
        else:
            base_path = util.translate_path(base_path)
        directory = os.path.dirname(base_path)
        if directory:
            util.ensure_directory(directory)
        return base_path

    # --- Nyilvános belépési pont: cache/frissítés kezelése ---
    def ensure_assets(self, force=False):
        state = util.read_json_file(self.state_path, {})
        # TTL default: 0.0 -> minden indításkor frissít
        ttl_hours = util.get_float_setting(self.addon, 'refresh_ttl_hours', 0.0)
        ttl_seconds = max(0, int(ttl_hours * 3600))
        now = util.now_ts()

        last_success = state.get('last_success', 0)
        need_refresh = force

        if not need_refresh:
            if not util.file_exists(self.playlist_path) or not util.file_exists(self.epg_path):
                need_refresh = True

        if not need_refresh and ttl_seconds:
            if now - last_success >= ttl_seconds:
                util.log_info('Cache expired, refreshing playlist assets')
                need_refresh = True

        if need_refresh:
            self._refresh_assets()

        return {
            'playlist_path': self.playlist_path,
            'epg_path': self.epg_path,
            'channels': self._load_channels(),
            'last_success': util.read_json_file(self.state_path, {}).get('last_success')
        }

    # --- Csatornák betöltése a legenerált M3U-ból ---
    def _load_channels(self):
        if self._channel_cache is not None:
            return self._channel_cache
        if not util.file_exists(self.playlist_path):
            return []
        text = util.read_text_file(self.playlist_path)
        if not text:
            return []
        self._channel_cache = m3u.parse(text)
        return self._channel_cache

    # --- Frissítési folyamat ---
    def _refresh_assets(self):
        util.log_info('Refreshing playlist and EPG sources')

        default_script = self._load_default_script()
        if not default_script:
            util.log_error('Unable to load playlist source script')
            return

        deobfuscated = self._deobfuscate(default_script)
        urls = self._extract_https_urls(deobfuscated)
        util.log_debug(f'Deobfuscated URLs: {urls}', enabled=self.debug_logging)

        index_entries = self._fetch_playlist_index(urls)
        if not index_entries:
            util.log_error('Playlist index could not be retrieved')
            return

        selected = self._select_hungary_entries(index_entries)
        if not selected:
            util.log_error('No Hungary entries discovered in index')
            return

        playlists = []
        epg_sources = []

        for entry in selected:
            playlist_url = entry.get('url') or entry.get('stream') or entry.get('link')
            if not playlist_url:
                continue

            playlist_data = self._download_playlist(playlist_url)
            if not playlist_data:
                continue

            playlists.append(m3u.parse(playlist_data))

            entry_epg = entry.get('epg') or entry.get('epg_url') or entry.get('epg_urls')
            if isinstance(entry_epg, list):
                epg_sources.extend(entry_epg)
            elif isinstance(entry_epg, str):
                epg_sources.append(entry_epg)

        merged = m3u.merge_playlists(playlists)
        rendered = m3u.render(merged)
        util.write_text_file(self.playlist_path, rendered)
        util.log_info(f'M3U written to {self.playlist_path}')

        self._channel_cache = merged

        epg.build_epg(merged, epg_sources, self.epg_path, debug_enabled=self.debug_logging)

        util.write_json_file(self.state_path, {
            'last_success': util.now_ts(),
            'last_checked': datetime.utcnow().isoformat() + 'Z'
        })

    # --- Forrás betöltők: BEE (telepített) -> BEE (disk path) -> Remote -> Fallback ---
    def _load_default_script(self):
        loaders = [
            self._load_installed_default,
            self._load_disk_bee_default,
            self._load_remote_default,
            self._load_fallback_default
        ]
        for loader in loaders:
            script = loader()
            if script:
                util.log_debug(f'Default script loaded via {loader.__name__}', enabled=self.debug_logging)
                return script
        return None

    def _load_installed_default(self):
        try:
            addon = util.get_addon(PLAYLIST_ADDON_ID)
        except Exception:
            return None
        addon_path = addon.getAddonInfo('path')
        file_path = os.path.join(addon_path, 'default.py')
        return util.read_text_file(file_path)

    def _load_disk_bee_default(self):
        # CoreELEC tipikus útvonal
        path = '/storage/.kodi/addons/plugin.video.playlistbee/default.py'
        if util.file_exists(path):
            return util.read_text_file(path)
        return None

    def _load_remote_default(self):
        url = self._resolve_remote_url()
        if not url:
            return None

        cache = util.read_json_file(self.cache_path, {})
        headers = {}
        if cache.get('etag'):
            headers['If-None-Match'] = cache['etag']
        if cache.get('last_modified'):
            headers['If-Modified-Since'] = cache['last_modified']

        token = util.get_setting(self.addon, 'github_token', None)
        if token:
            headers['Authorization'] = f'token {token}'

        status, data, response_headers = util.http_request(url, headers=headers, timeout=45)
        if status == 304 and cache.get('content'):
            util.log_info('Remote default.py not modified, using cached copy')
            return cache.get('content')
        if status != 200:
            util.log_warning(f'Remote default.py request failed: {status}')
            return None

        text = data.decode('utf-8', errors='ignore')
        cache_payload = {
            'content': text,
            'etag': response_headers.get('ETag') or response_headers.get('Etag'),
            'last_modified': response_headers.get('Last-Modified'),
            'last_checked': util.now_ts(),
            'source_url': url
        }
        util.write_json_file(self.cache_path, cache_payload)
        return text

    def _resolve_remote_url(self):
        raw_url = util.get_setting(self.addon, 'playlist_default_raw_url', None)
        if raw_url:
            return raw_url
        owner = util.get_setting(self.addon, 'playlist_repo_owner', None)
        name = util.get_setting(self.addon, 'playlist_repo_name', None)
        branch = util.get_setting(self.addon, 'playlist_repo_branch', 'main')
        path = util.get_setting(self.addon, 'playlist_repo_path', None)
        if all([owner, name, branch, path]):
            return f'https://raw.githubusercontent.com/{owner}/{name}/{branch}/{path}'
        return None

    def _load_fallback_default(self):
        addon_path = self.addon.getAddonInfo('path') if self.addon else ''
        if not addon_path:
            return None
        fallback_path = os.path.join(addon_path, 'resources', 'fallback_default.py')
        content = util.read_text_file(fallback_path)
        if not content:
            return None
        match = FALLBACK_PATTERN.search(content)
        if match:
            payload = match.group(1).strip().encode('utf-8')
            try:
                decoded = base64.b64decode(payload)
                return zlib.decompress(decoded).decode('utf-8', errors='ignore')
            except Exception:
                util.log_warning('Failed to decode embedded fallback payload')
                return None
        return content

    # --- Deobfuszkálás ---
    def _deobfuscate(self, script):
        current = script
        safety = 0
        while safety < 10:
            match = EXEC_PATTERN.search(current)
            if not match:
                break
            literal = match.group(1)
            try:
                payload = ast.literal_eval(literal)
            except (SyntaxError, ValueError):
                util.log_warning('Unable to evaluate obfuscated payload')
                break
            decoded = self._decode_payload(payload)
            current = decoded.decode('utf-8', errors='ignore')
            safety += 1
        return current

    def _decode_payload(self, data):
        reversed_bytes = data[::-1]
        base64_decoded = base64.b64decode(reversed_bytes)
        return zlib.decompress(base64_decoded)

    # --- URL-ek kinyerése: splitelt literálok kezelése is ---
    def _extract_https_urls(self, script):
        urls = list(dict.fromkeys(HTTPS_PATTERN.findall(script)))
        if urls:
            return urls
        # Ha a kód 'https://' + 'pastebin' + ... módon van szétszedve:
        collapsed = re.sub(r'[\s\"\'\+]+', '', script)
        extra = re.findall(r'https://[A-Za-z0-9\-._~:/?#\[\]@!$&()*+,;=%]+', collapsed)
        return list(dict.fromkeys(extra))

    # --- Index letöltése (JSON és/vagy egyszerű szöveg) ---
    def _fetch_playlist_index(self, urls):
        for url in urls:
            status, data, headers = util.http_request(url, timeout=45)
            if status != 200 or not data:
                continue
            try:
                text = util.maybe_decompress(data, headers, url).decode('utf-8', errors='ignore')
            except Exception:
                continue

            # 1) JSON-ként
            try:
                payload = json.loads(text)
                entries = payload.get('entries') or payload.get('items') if isinstance(payload, dict) else payload
                if isinstance(entries, list):
                    norm = []
                    for e in entries:
                        if not isinstance(e, dict):
                            continue
                        name = e.get('name') or e.get('title') or e.get('label') or e.get('url') or ''
                        link = e.get('url') or e.get('link') or e.get('stream') or ''
                        if link:
                            d = {k: v for k, v in e.items() if k not in ('name','title','label','url','link','stream')}
                            d.update({'name': name, 'url': link})
                            norm.append(d)
                    if norm:
                        util.log_info('Playlist index (JSON) ok: %d elem' % len(norm))
                        return norm
            except Exception:
                pass

            # 2) Egyszerű szöveg: M3U linkek keresése
            candidates = []
            for m in re.finditer(r'https?://[^\s\'"]+', text):
                u = m.group(0)
                lu = u.lower()
                if lu.endswith(('.m3u', '.m3u8')) or 'm3u' in lu:
                    candidates.append({'name': u, 'url': u})
            if candidates:
                util.log_info('Playlist index (plaintext) ok: %d jelölt' % len(candidates))
                return candidates

        return []

    # --- Hungary/Ungary szűrés + fallback ---
    def _select_hungary_entries(self, entries):
        def is_hu(e):
            name = (e.get('name') or e.get('title') or e.get('label') or '').lower()
            url  = (e.get('url') or e.get('link') or e.get('stream') or '').lower()
            return (
                'hungary' in name or 'hungary' in url or
                'hungarian' in name or 'hungarian' in url or
                'magyar' in name or 'magyar' in url or
                'ungary' in name or 'ungary' in url or  # elütés kezelése (Ungary)
                '/hu' in url
            )

        hu = [e for e in entries if is_hu(e)]
        if not hu:
            fallback = []
            for e in entries:
                u = (e.get('url') or e.get('link') or e.get('stream') or '').lower()
                if u.endswith(('.m3u', '.m3u8')) or 'm3u' in u:
                    fallback.append(e)
                if len(fallback) >= 3:
                    break
            if fallback:
                util.log_warning('Hungary filter empty, fallback to %d entries' % len(fallback))
                return fallback[:3]
            util.log_warning('Hungary filter and fallback both empty')
            return []
        if len(hu) < 3:
            util.log_warning('Hungary playlist count below expectation: %d' % len(hu))
        return hu[:3]

    # --- M3U letöltés/dekompresszió ---
    def _download_playlist(self, url):
        status, data, headers = util.http_request(url, timeout=45)
        if status != 200 or not data:
            util.log_warning(f'Failed to download playlist from {url} (status={status})')
            return None
        try:
            payload = util.maybe_decompress(data, headers, url)
        except Exception:
            util.log_warning(f'Unable to decompress playlist data from {url}')
            return None
        return payload.decode('utf-8', errors='ignore')
